#!/usr/bin/perl

#
# lapimport
#
# This script will import CSV Lapd data into the RaceReplay database.
#
# The lapd data consists of timing data that has been pre-processed to create
# lap records that additionally have per lap information for the user and 
# group information for the group that the user was with when the activation
# record was recorded.
#
# The CSV file is opened via DBI::CSV and for each row. 
#
# For reach activation record (possibly a lap record at this point) the following tables may be
# used or updated:
#
#       racereplay.venues
#               - if required, create a venue record for where the data was recorded
#               - typically all records for a single file will be for the same venue
#               - typically all venues should already exist
#
#       racereplay.chips
#               - if required, create a chip record for the transponder chip used
#               - this allows unknown transponders to be safely used without prior knowledge
#
#       racereplay.groupsets
#               - create a groupset record when required
#
#       racereplay.workouts
#               - create a workout record when required
#
#       racereplay.races
#               - create a race record when required
#
#       racereplay.raceinfo
#               - create a raceinfo record when required
#
#       racereplay.racelaps
#               - create a racelap record when required
#
#
#       racereplay.laps
#               - create a lap record
#               - set fields as needed
#
#               - update workout finishtime, totalms, bestlapms and laps 
#               - update groupset lengthms, gapms and members
#               - update chip activations, replacebattery, batteryreplaced 
#
# 
#
# This script can run in two modes:
#
#       - run against a list of files
#       - Follow Me Mode
#
# File list usage:
#
#       cd $DIRECTORY
#       lapimport FILES [....]
#
# Follow Me Mode usage:
#       
#       cd $DIRECTORY
#       lapimport
#
# The Follow Me Mode is designed to run as a long running service. Typically it will be started
# from an init.d startup script.
#
# It will respond to signals:
#
#       TERM - terminate
#       QUIT - terminate
#       HUP - terminate
#       INT - restart
#
#

# Current fields expected in the incoming CSV file:
#
#       "datestamp"     Time and date stamp when recorded. 
#       "venue"         Where recorded.
#       "boxid"         Timing unit identifier.
#       "eventid"       Event id from timing unit.
#       "rx"            RX Number from timing unit.
#       "tagid"         Transponder TAG identifier.
#       "batt"          Batter OK flag.
#       "corr"          The number of times the transponder transmitted before being recognized.
#       "finishms"      Milli-seconds at the end of the lap.
#       "startms"       Milli-seconds at the beginning of the lap (if present, may be zero).
#       "groupms"       Milli-seconds from beginning of group.
#       "lapms"         Total milli-seconds for recorded lap (may be zero).
#       "workoutlap"     Lap number within a set of laps.
#       "groupnumber"   Number withing a group.
#       "gapms"         Milli-seconds from previous group if first in group.
#       "skippedflag"   Number of possible skipped laps.
#




my $TRANSACTIONS = 0;
my $DEBUG = 1;
my $VERBOSE = 1;


use strict;
use warnings;
use Time::CTime;
use DBI;
use Data::Dumper;
use SQL::Abstract;
use File::Tail;
use DateTime;
use DateTime::TimeZone;
use DateTime::Locale;
use DateTime::Format::Strptime;
use Sys::Syslog qw (:standard :macros);
use Cwd;


#my $DATABASE = "racetest";
#my $DBUSER = "racetest";
#my $DATABASE = $dir;
#my $DBUSER = $dir;
#my $DBPASSWORD = "aa.bb.cc";



BEGIN {
    my $dir = fastcwd;
    my @values = split(/\//, $dir);
    push (@INC, sprintf("/%s/%s/%s/bin", $values[1], $values[2], $values[3]));
    #printf STDERR "INC: %s\n", join(";", @INC); 
}

use My::SqlDef qw(SqlConfig);
use My::SimpleCSV qw(init parse);
use My::FKey qw(init find finish);
use My::Misc qw(find_chipid);

my ($DATABASE, $DBUSER, $DBPASSWORD) = SqlDef::SqlConfig();

printf STDERR "%s %s %s\n", $DATABASE, $DBUSER, $DBPASSWORD;

sub dodef {
    my ($ref) = @_;
    return $ref if (defined($ref));
    return "";
}
sub dodef0 {
    my ($ref) = @_;
    return $ref if (defined($ref));
    return 0;
}



my (%VenueIDs, %VenueDistances, %LapTime, %Lapms, %Laps, %Activations, 
        %LapSetid, %LapTotalms, %LapBestms, %LapCorrections, %LapSkippedCount, %LapBattery);

my %UKey;

my $GroupDatestamp = "";
my $GroupMembers = 0;
my $GroupMS = 0;
my $GroupLengthMS = 0;
my $GroupSetid = 0;
my $GroupGapMS = 0;
my $GroupStartMS = 0;

my $LastRX = 0;

my @GroupMembersList;           # current list of riders in a group
my $GroupMembersLapZero = 0;    # number of riders in current group in lap zero

                                # Indexed by tagid
my $ActiveRaces = 0;            # number of active races
my %RacerRaceID;                # current raceid for a tagid
my %RacerRaceInfoID;            # current raceinfoid for a tagid
my %ActiveLast;                 # last time tagid seen

                                # Indexed by raceid
my %RaceInfoIDs;                # current raceinfoid
my %RaceLapNumber;              # current lapnumber
my %RacesActiveCount;           # current number of active racers
my $RaceLapFinishOrder;         # number of finishers in current race lap

my $NextRaceID = 0;
my $NextRaceInfoID = 0;


######################################################################################################################


sub diemsg {
        my ($line, $msg, $sth) = @_;
        unless (defined($msg) && defined($sth)) {
            die sprintf("LINE: %d msg or sth not defined\n", $line);
        }
        if (defined($sth)) {
            if (defined($sth->{'statement'})) {
                die sprintf("%s(%d):%s\n%s\n", $msg, $line, $sth->errstr, $sth->{'statement'});
            }
            else {
                die sprintf("%s(%d):%s\n", $msg, $line, $sth->errstr);
            }
        }
        die sprintf("%s\nSTH NOT DEFINED\n", $msg);
}

# get_venueid
#
# get or create a venueid
#
sub get_venueid {
    my ($dbh, $venue) = @_;

    unless (defined($VenueIDs{$venue})) {

        my $row = Misc::get_venue_info($dbh, $venue);

        unless($row) {
            die "Cannot find venue! %s\n", $venue;
        }

        $VenueIDs{$venue} = $row->{'venueid'};
        $VenueDistances{$venue} = $row->{'distance'};

        printf STDERR "found venue: %s venueid: %d distance: %d\n", $venue, $VenueIDs{$venue}, $VenueDistances{$venue};
    }
    return ($VenueIDs{$venue}, $VenueDistances{$venue});
}

######################################################################################################################


# insert_raceinfo
#
# Create a new race record properly initialized.
#
my ($sRaceLapSth, $iRaceLapSth, $uRaceSth);
sub insert_raceinfo {
    my ($dbsql, $raceid, $trackflag, $startflag, $neutralflag, $finishms, $msg) = @_;

    #printf STDERR "\n-------------------\n" if ($DEBUG);
    #printf STDERR "insert_raceinfo - finishms: %s %s\n", $finishms, $msg;
    #printf STDERR "%%RaceLapNumber - current lapnumber by raceid\n";
    #printf STDERR Dumper(\%RaceLapNumber);
    my $lapnumber = $RaceLapNumber{$raceid}++;

    printf STDERR "INSERT INTO raceinfo (raceid,lapnumber,racelap,finishms) VALUES(%s,%s,%s)\n", $raceid, $lapnumber, $lapnumber, $finishms if ($VERBOSE);

    $iRaceLapSth =   $dbsql->prepare('INSERT INTO raceinfo  (raceid,lapnumber,racelap,startflag,neutralflag,finishms) VALUES(?,?,?,?,?,?)')
        unless(defined($iRaceLapSth));

    unless ($iRaceLapSth->execute($raceid, $lapnumber, $lapnumber, $startflag, $neutralflag, $finishms)) {
        printf STDERR "%s - races\n", $iRaceLapSth->errstr; # if ($VERBOSE);
    }

    return if ($startflag);

    # get raceinfoid
    #
    printf STDERR "SELECT raceinfoid FROM races WHERE raceid=%s\n", $raceid if ($DEBUG);
    
    $sRaceLapSth =   $dbsql->prepare('SELECT raceinfoid  FROM raceinfo  WHERE raceid=? AND lapnumber=?') 
        unless(defined($sRaceLapSth));

    $sRaceLapSth->execute($raceid, $lapnumber) || diemsg(__LINE__, "insert_races: Cannot find raceinfoid:", $sRaceLapSth);
    my $srow = $sRaceLapSth->fetchrow_hashref();

    unless (defined($srow)) {
        diemsg(__LINE__, "insert_races: Could not find raceid:", $sRaceLapSth);
    }
    my $RaceInfoID = $srow->{'raceinfoid'};

    # reset the appropriate fields associated with this tagid
    #
    $RaceInfoIDs{$raceid} = $RaceInfoID;                 # index by raceid, holds current raceinfoid
    $RaceLapFinishOrder = 0;


    # update race
    my $racelaps = $trackflag ? $lapnumber - 1 : $lapnumber;
    $uRaceSth = $dbsql->prepare('UPDATE races SET lastlap=?, racelaps=? WHERE raceid=?')
        unless(defined($uRaceSth));

    $uRaceSth->execute($lapnumber, $racelaps, $raceid) || diemsg(__LINE__, "Could not update race", $uRaceSth);

    printf STDERR "RaceInfoID: %s\n", $RaceInfoID if ($DEBUG);
}

# insert_race
#
# Create a new race record properly initialized.
#
my ($sRaceSth, $iRaceSth);
sub insert_race {
    my ($dbsql, $trackflag, $groupsetid, $entries, $finishms ) = @_;

    #printf STDERR "\n-------------------\n" if ($DEBUG);
    printf STDERR "INSERT INTO races (groupsetid,description,racetype,entries,startms) VALUES(%s,\"\",\"\",%s)\n", $groupsetid, $entries, $finishms if ($VERBOSE);

    $iRaceSth = $dbsql->prepare('INSERT INTO races (groupsetid,description,racetype,entries,startms) VALUES(?,"","",?,?)') 
        unless(defined($iRaceSth));

    unless ($iRaceSth->execute($groupsetid, $entries, $finishms)) {
        printf STDERR "%s - races\n", $iRaceSth->errstr; # if ($VERBOSE);
    }

    # get raceid
    #
    printf STDERR "SELECT raceid FROM races WHERE groupsetid\n", $groupsetid if ($DEBUG);

    $sRaceSth =      $dbsql->prepare('SELECT raceid FROM races WHERE groupsetid=?')
        unless(defined($sRaceSth));
    $sRaceSth->execute($groupsetid) || diemsg(__LINE__, "insert_races: Cannot find racesid", $sRaceSth);
    my $srow = $sRaceSth->fetchrow_hashref();

    unless (defined($srow)) {
        diemsg(__LINE__, "insert_races: Could not find racesid", $sRaceSth);
    }
    #$sRaceSth->finish();
    my $RaceID = $srow->{'raceid'};
    

    # reset the appropriate fields associated with this tagid
    #
    $RaceInfoIDs{$RaceID} = 0;                 # index by raceid, holds current raceinfoid
    $RacesActiveCount{$RaceID} = 0;           # index by raceid, holds current number of active racers
    $RaceLapNumber{$RaceID} = 0;              # current lapnumber

    printf STDERR "RaceID: %s\n", $RaceID if ($DEBUG);
    
    insert_raceinfo($dbsql, $RaceID, $trackflag, 1, 0, $finishms, "Start Lap");

    for (my $i = 1; $i <= $#GroupMembersList; $i++) {
        #printf STDERR "GROUP[%2d] %s\n", $i, $GroupMembersList[$i];
        my $tagid = $GroupMembersList[$i];
        if (defined($RacerRaceID{$tagid})) {
        }
        $RacesActiveCount{$NextRaceID}++;
        $RacerRaceID{$tagid} = $RaceID;
    }

    $ActiveRaces++;
}



######################################################################################################################

# update_workout
#
# At the end of a workout this is called to update workout information. Note that this also updates
# the chips records for the # appropriate chipid.
#
my ($uWorkoutChipSth);
sub update_workout {

    my ($dbsql, $tagid, $chipid) = @_;

    my $battery = $LapBattery{$tagid};
    my $laps = $Laps{$tagid};
    my $activations = $Activations{$tagid};

    # The replacebattery flag is set if we have a significant number of missed BATT OK
    # flags (less than 90%) and a reasonable sample size (> 20)
    #
    my $replacebattery = 0;
    if ($activations) {
        $replacebattery = 1 if (($activations > 20) && ($battery / $activations) < .9);
    }

    printf STDERR "UPDATE workouts w 
                SET w.finishtime=%s, w.laps=%s, w.totalms=%s, w.bestlapms=%s, w.battery=%s, w.skippedcount=%s, w.corrections=%s
                WHERE w.workoutid=%s\n",
                $LapTime{$tagid}, $laps, $LapTotalms{$tagid}, $LapBestms{$tagid}, $battery, $LapSkippedCount{$tagid}, $LapCorrections{$tagid},
                $LapSetid{$tagid}
        if ($DEBUG);


    $uWorkoutChipSth=$dbsql->prepare(
            'UPDATE workouts w 
            SET w.finishtime=?, w.laps=?, w.totalms=?, w.bestlapms=?, w.battery=?, w.skippedcount=?, w.corrections=?
            WHERE w.workoutid=?')
        unless(defined($uWorkoutChipSth));

    $uWorkoutChipSth->execute(
                $LapTime{$tagid}, $laps, $LapTotalms{$tagid}, $LapBestms{$tagid}, $battery, $LapSkippedCount{$tagid}, $LapCorrections{$tagid},
                $LapSetid{$tagid}
           ) || diemsg(__LINE__, "Could not update workout", $uWorkoutChipSth);
    
    # undef everything
    #
    delete $LapSetid{$tagid};
    delete $LapTime{$tagid};
    delete $Laps{$tagid};
    delete $Lapms{$tagid};
    delete $LapTotalms{$tagid};
    delete $LapBestms{$tagid};
    delete $LapCorrections{$tagid};
    delete $LapSkippedCount{$tagid};
    delete $LapBattery{$tagid};
    delete $Activations{$tagid};
}

# update groupset
#
# At the end of a set of activations in a single group this is called to update the groupset 
# record with the appropriate information.
#
my ($sGroupsetSth, $iGroupsetSth, $uGroupsetSth);
sub update_groupset {

    my ($dbsql, $trackflag, $finishms) = @_;

    #printf STDERR "--------------------------------\n";

    $uGroupsetSth = $dbsql->prepare('UPDATE groupsets SET datestamp=?, members=?, lengthms=? WHERE groupsetid=?')
        unless(defined($uGroupsetSth));

    unless ($GroupMembers == 1) {
        printf STDERR "UPDATE groupsets SET datestamp=%s members=%s lengthms=%s WHERE groupsetid=%s\n",
               $GroupDatestamp, $GroupMembers, $GroupLengthMS, $GroupSetid if ($DEBUG);

        $uGroupsetSth->execute($GroupDatestamp, $GroupMembers, $GroupLengthMS, $GroupSetid) || diemsg(__LINE__, "Could not insert groupsets", $uGroupsetSth);
    }


    if (($GroupMembers >= 4) && (($GroupMembersLapZero / $GroupMembers) > .9)) {

        printf STDERR "\n\n---------------------------------------\n";
        printf STDERR "RACE GroupMembers: %d GroupMembersLapZero: %d percent: %5.2f\n", $GroupMembers, $GroupMembersLapZero, (($GroupMembersLapZero / $GroupMembers) > .9);

        insert_race($dbsql, $trackflag, $GroupSetid, $GroupMembers, $GroupStartMS);
    }

    $GroupStartMS = 0;
    $GroupDatestamp = "";
    $GroupMembers = 0;
    $GroupLengthMS = 0;
    $GroupSetid = 0;

    $GroupMembersLapZero = 0;
    @GroupMembersList = ();     
}

######################################################################################################################

# insert_groupset
#
# Create a new groupset record properly initialized.
#
sub insert_groupset {
    my ($dbsql, $venueid, $datestamp, $finishms, $gapms) = @_;

    printf STDERR "INSERT INTO groupsets (venueid,datestamp,members,lengthms,gapms) VALUES(%s,%s,1,0,%s)\n", $venueid, $datestamp, $gapms if ($VERBOSE);

    $iGroupsetSth =  $dbsql->prepare('INSERT INTO groupsets (venueid,datestamp,members,lengthms,gapms) VALUES(?,?,?,?,?)')
        unless(defined($iGroupsetSth));

    unless ($iGroupsetSth->execute($venueid, $datestamp, 1, 0, $gapms)) {
        printf STDERR "%s - groupsets\n", $iGroupsetSth->errstr; # if ($VERBOSE);
    }

    # get groupsetid
    #
    printf STDERR "SELECT groupsetid FROM groupsets WHERE venueid=%s AND datestamp=%s\n", $venueid, $datestamp if ($DEBUG);

    $sGroupsetSth =  $dbsql->prepare('SELECT groupsetid FROM groupsets WHERE venueid=? AND datestamp=?')
        unless(defined($sGroupsetSth));

    $sGroupsetSth->execute($venueid, $datestamp) || diemsg(__LINE__, "insert_groupset: Cannot find groupsetid", $sGroupsetSth);
    my $srow = $sGroupsetSth->fetchrow_hashref();

    unless (defined($srow)) {
        diemsg(__LINE__, "insert_groupset: Could not find groupsetid", $sGroupsetSth);
    }
    #$sGroupsetSth->finish();

    # reset the appropriate fields associated with this tagid
    #
    $GroupSetid = $srow->{'groupsetid'};
    $GroupDatestamp = $datestamp;
    $GroupMembers = 0;
    $GroupMS = 0;
    $GroupLengthMS = 0;
    $GroupGapMS = $finishms;
    $GroupMembersLapZero = 0;
    @GroupMembersList = ();     

    $GroupStartMS = $finishms;

    printf STDERR "GroupSetid: %s GroupStartMS: %d\n", $GroupSetid, $GroupStartMS if ($DEBUG);
}


# insert_workout
#
# Create a new workout record properly initialized.
#
my ($sWorkoutSth, $iWorkoutSth);
sub insert_workout {
    my ($dbsql, $venueid, $tagid, $chipid, $datestamp, $boxid, $lapms, $startms, $finishms, $groupms) = @_;

    #printf STDERR Dumper(\@_);

    printf STDERR "INSERT INTO workouts (venueid,chipid,starttime,finishtime,totalms,laps,boxid,battery,skippedcount,corrections) VALUES(%s,%s,%s,%s,%s,%s,%s,%s,%s)\n",
           $venueid, $chipid, $datestamp, "", "0", "0", "0", $boxid, "0", "0", "0" if ($VERBOSE);

    $iWorkoutSth =   $dbsql->prepare('
        INSERT INTO workouts  
        (venueid,chipid,starttime,finishtime,totalms,bestlapms,laps,boxid,battery,skippedcount,corrections) 
        VALUES(?,?,?,?,?,?,?,?,?,?,?)')
        unless(defined($iWorkoutSth));


    # may fail if it was previously inserted
    #
    unless ($iWorkoutSth->execute($venueid, $chipid, $datestamp, "", "0", "0", "0", $boxid, "0", "0", "0")) {
        printf STDERR "%s - workouts\n", $iWorkoutSth->errstr; # if ($VERBOSE);
    }

    # get workoutid
    #

    $sWorkoutSth =   $dbsql->prepare('SELECT workoutid  FROM workouts  WHERE chipid=? AND starttime=?')
        unless(defined($sWorkoutSth));

    $sWorkoutSth->execute($chipid, $datestamp) || diemsg(__LINE__, "Cannot find workoutid", $sWorkoutSth);

    my $srow = $sWorkoutSth->fetchrow_hashref();
    unless (defined($srow)) {
        diemsg(__LINE__, "Could not find workoutid", $sWorkoutSth);
    }
    #$sWorkoutSth->finish();

    # reset the appropriate fields associated with this tagid
    #
    $LapSetid{$tagid} = $srow->{'workoutid'};
    $Laps{$tagid} = -1;
    $Activations{$tagid} = 0;
    $LapBestms{$tagid} = $lapms;
    $LapCorrections{$tagid} = 0;
    $LapSkippedCount{$tagid} = 0;
    $LapBattery{$tagid} = 0;

    # reset old race activity if present
    #
    if (defined($RacerRaceID{$tagid})) {
        delete($RacerRaceID{$tagid}); 
        $RacesActiveCount{$tagid}++;
    }

}

# insert lap data
#
# Insert the actual per lap data.
#
my ($sLapSth, $iLapSth, $iRaceInfoSth);
sub insert_lap {

    my ($dbsql, $tagid, $datestamp, $workoutid, $groupsetid, $laps, $finishms, $startms, $groupnumber, $groupms, $lapms, $batteryflag, $corr, $skippedflag) = @_;

    printf STDERR "INSERT INTO laps (datestamp,workoutid,groupsetid,workoutlap,finishms,startms,groupnumber,groupms,lapms,battery,correction,skippedflag) 
        VALUES(%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)\n",
        $datestamp, $workoutid, $groupsetid, $laps,$finishms,$startms,$groupnumber,$groupms,$lapms,$batteryflag,$corr,$skippedflag 
            if ($DEBUG);

    $iLapSth = $dbsql->prepare(
            'INSERT INTO laps (datestamp,workoutid,groupsetid,workoutlap,finishms,startms, groupnumber,groupms,lapms,battery,correction,skippedflag) 
            VALUES(?,?,?,?,?,?,?,?,?,?,?,?)')
        unless(defined($iLapSth));

    unless ($iLapSth->execute($datestamp, $workoutid, $groupsetid, $laps,$finishms,$startms,$groupnumber,$groupms,$lapms,$batteryflag, $corr,$skippedflag)) {
        printf STDERR "insert lap %s\n", $iLapSth->errstr; # if ($VERBOSE);
    }
    
    return unless (defined($RacerRaceID{$tagid}));

    # add racelaps entry if required, lookup the raceinfoid and get the just inserted lapid
    #
    my $raceinfoid = $RacerRaceInfoID{$tagid};

    #printf STDERR "%%RacerRaceInfoID\n";
    #printf STDERR Dumper(%RacerRaceInfoID);

    $sLapSth =  $dbsql->prepare('SELECT * FROM laps WHERE workoutid=? AND datestamp=?')
        unless(defined($sLapSth));

    $sLapSth->execute($workoutid, $datestamp) || diemsg(__LINE__, "select laps: Cannot find laps:", $sLapSth);
    my $srow = $sLapSth->fetchrow_hashref();

    unless (defined($srow)) {
        diemsg(__LINE__, "insert_races: Could not find raceid:", $sLapSth);
    }

    my $lapid = $srow->{'lapid'};
        
    printf STDERR "INSERT INTO racelaps (lapid,raceinfoid)  VALUES(%s,%s)\n", $lapid, $raceinfoid
        if ($DEBUG);


    my $finishorder = ++$RaceLapFinishOrder;

    $iRaceInfoSth = $dbsql->prepare( 'INSERT INTO racelaps (lapid,raceinfoid,finishorder)  VALUES(?,?,?)')
        unless(defined($iRaceInfoSth));

    unless ($iRaceInfoSth->execute($lapid, $raceinfoid, $finishorder)) {
        diemsg(__LINE__, "insert raceinfo:", $iRaceInfoSth);
    }
}

# do_laps_init
#
# initialize global searches
#
sub do_laps_init {
    my ($dbsql) = @_;

    #printf STDERR "do_laps_init:\n";

    %UKey = FKey::init($dbsql, 'venue');

}

# do_laps_finish
#
# cleanup
#
sub do_laps_finish {

    my ($dbsql, $trackflag) = @_;

    # Update race records
    #
    #update_race($dbsql) if ($ActiveRaces);

    # Dump last group record. There is only one.
    #
    update_groupset($dbsql, $trackflag, 0) if ($GroupDatestamp ne "");

    # Update workout records in progress. There may be many of them.
    #
    foreach my $tagid (sort keys(%Lapms)) {
        my $chipid = Misc::find_chipid($dbsql, $tagid);
        #printf STDERR "tagid: %s\n", $chipid;
        update_workout($dbsql, $tagid, $chipid);
    }

    $sWorkoutSth->finish();
    $iWorkoutSth->finish();
    $iGroupsetSth->finish();
    $uGroupsetSth->finish();
    $iLapSth->finish();
    FKey::finish(%UKey);
    $dbsql->commit() if ($TRANSACTIONS);
}


# These are declared here to improve performance 
#
my ($datestamp, $venue, $boxid, $tagid, $finishms, $startms, $groupms, $lapms, $corr, $gapms, $skippedflag, $batteryflag, $raceinfoid, $rx);


sub DEF {
    my ($value) = @_;

    return "UNDEF" unless(defined($value));
    return $value;
}

# do_lap
#
# Process a single row of timing data.
#
sub do_lap {

    my ($dbsql, $count, $row) = @_;

    next unless(defined($row));

    printf STDERR "\n[%d]=========================================\n\n", $count;

    # make sure we don't have any undefined values
    foreach my $key (keys(%{$row})) { unless (defined($row->{ $key })) { $row->{ $key } = ""; } }

    $datestamp = $row->{'datestamp'};
    $venue = $row->{'venue'};
    $boxid = $row->{'boxid'};
    $tagid = $row->{'tagid'};
    $finishms = $row->{'finishms'};
    $startms = $row->{'startms'};
    $groupms = $row->{'groupms'};
    $lapms = $row->{'lapms'};
    $corr = hex($row->{'corr'});
    $gapms = $row->{'gapms'};
    $skippedflag = dodef0($row->{'skippedflag'});
    $batteryflag = dodef0($row->{'batt'});
    $raceinfoid = 0;
    $rx = $row->{'rx'};

    my ($date,$time) = split(/ /, $datestamp);

    printf STDERR "%s %s: %s finishms: %s startms: %s  groupms: %s Group Datestamp: %s Count: %s MS: %s gapms: %s batteryflag: %d skippedflag: %d\n", 
           $date, $datestamp, $tagid, $finishms, $startms, $groupms, $GroupDatestamp, $GroupMembers, $GroupMS, $gapms, $batteryflag, $skippedflag if ($DEBUG);


    if ($rx eq $LastRX) {
        printf STDERR "\nDuplicate RX! LastRX: %s RX: %s\n", $LastRX, $rx;
        printf STDERR "%s: %s finishms: %s startms: %s  groupms: %s Group Datestamp: %s Count: %s MS: %s gapms: %s batteryflag: %d skippedflag: %d\n", 
               $datestamp, $tagid, $finishms, $startms, $groupms, $GroupDatestamp, $GroupMembers, $GroupMS, $gapms, $batteryflag, $skippedflag if ($DEBUG);
        return;
    }

    $LastRX = $rx;


    unless(defined($tagid)) { die "Bad Chip value"; }
    unless(defined($venue)) { die "Bad Venue value"; }

    # Find venueid
    my ($venueid, $distance) = get_venueid($dbsql, $venue);

    my $TrackFlag = $distance <= .5;

    # If this is not a member of the current groupset then update the groupset, may do insert_race
    #
    update_groupset($dbsql, $TrackFlag, $finishms) if ($GroupDatestamp ne "" && $groupms == 0);

    # Insert a new groupset record if this is a new group.
    #
    insert_groupset($dbsql, $venueid, $datestamp, $finishms, $gapms) if ($GroupDatestamp eq "");


    # Find or create a chipid 
    #
    my $chipid = Misc::find_chipid($dbsql, $tagid);



    # Is there an existing workout for this tag that is not for this workout?
    # The startms for this record must be the same as the finishms for the most recent record
    # in the workout. This also updates the chip records.
    #
    update_workout($dbsql, $tagid, $chipid) if (defined($Lapms{$tagid}) && ($Lapms{$tagid} ne $startms));

    # Insert a new workout record if this is a new workout. 
    #
    insert_workout ($dbsql, $venueid, $tagid, $chipid, $datestamp, $boxid, $lapms, $startms, $finishms, $groupms) unless (defined($Lapms{$tagid}));

    # Update group info (after insert_workout so $Laps{$tagid} is initialized)
    #
    $GroupMembers++;
    $GroupMembersList[$GroupMembers] = $tagid;
    $GroupLengthMS = $groupms;

    #printf STDERR "%%Laps - current laps for each tagid\n";
    #printf STDERR Dumper(\%Laps);
    
    #printf STDERR "Laps{%s} %d\n", $tagid, $Laps{$tagid};

    #$GroupMembersLapZero++ unless ($Laps{$tagid});
    if ($Laps{$tagid} == -1) {
        $GroupMembersLapZero++;
        #printf STDERR "tagid: %s laps: %d GroupMembersLapZero: %d\n", $tagid, $Laps{$tagid}, $GroupMembersLapZero;
    }

    # Update Race info
    #
    if (defined($RacerRaceID{$tagid})) {


        # get current raceid for this rider
        #
        my $raceid = $RacerRaceID{$tagid};

        #printf STDERR "%%RacerRaceID - current raceid's for all tags\n";
        #printf STDERR Dumper(\%RacerRaceID);

        #printf STDERR "%%RaceInfoIDs - current raceinfoid for each race\n";
        #printf STDERR Dumper(\%RaceInfoIDs);
        #printf STDERR "%%RaceLapNumber - current racelap for each race\n";
        #printf STDERR Dumper(\%RaceLapNumber);

        #printf STDERR "tagid: %s\n", $tagid;
        #printf STDERR "RaceID: %s\n", $raceid;

        #printf STDERR "RacerRaceID{%s} %s\n", $tagid, DEF($RacerRaceID{$tagid});
        #printf STDERR "RacerRaceInfoID{%s} %s\n", $tagid, DEF($RacerRaceInfoID{$tagid});
        #printf STDERR "RaceInfoIDs{%s} %s\n", $raceid, DEF($RaceInfoIDs{$raceid});
        #printf STDERR "RaceLapNumber{%s} %s\n", $raceid, DEF($RaceLapNumber{$raceid});

        # do we need to create a racelap record
        #my $neutralflag = $distance == .2;
        my $neutralflag = 0;
        insert_raceinfo($dbsql, $raceid, $TrackFlag, 0, $neutralflag, $finishms, "First Lap") 
            if(!defined($RaceInfoIDs{$raceid}) || ($RaceInfoIDs{$raceid} == 0));
        

        # check if there is an existing raceinfoid for this rider and if it is the same as the current
        # raceinfoid then we allocate a new one.
        #
        insert_raceinfo($dbsql, $raceid, $TrackFlag, 0, 0, $finishms, "New Lap") 
            if (defined($RacerRaceInfoID{$tagid}) && ($RacerRaceInfoID{$tagid} == $RaceInfoIDs{$raceid}));

        #printf STDERR "%%RaceInfoIDs - current raceinfoid for each race\n";
        #printf STDERR Dumper(\%RaceInfoIDs);

        $raceinfoid = $RaceInfoIDs{$raceid};
        $RacerRaceInfoID{$tagid} = $raceinfoid;
        
        #printf STDERR "%%RacerRaceInfoID - current raceinfoid for each tagid\n";
        #printf STDERR Dumper(\%RacerRaceInfoID);
        
        #printf STDERR "RACER RaceID: %s RaceInfoID: %s\n", $raceid, $raceinfoid;
    }


    # Update workout info 
    #
    $LapTime{$tagid} = $datestamp;
    $Lapms{$tagid} = $finishms;
    $LapBestms{$tagid} = $lapms if (($LapBestms{$tagid} == 0) || ($LapBestms{$tagid} > $lapms));


    # Update lap info
    #
    $Activations{$tagid}++;
    #$Laps{$tagid}++ if ($startms > 0);
    $Laps{$tagid}++;
    $LapTotalms{$tagid} += $lapms;
    $LapCorrections{$tagid} += $corr;
    $LapSkippedCount{$tagid} += $skippedflag;
    $LapBattery{$tagid} += $batteryflag;
    $ActiveLast{$tagid} = $finishms;

    # Finally, insert a new lap record.
    #
    insert_lap($dbsql, $tagid, $datestamp, $LapSetid{$tagid}, $GroupSetid, 
            $Laps{$tagid}, $finishms, $startms, $GroupMembers, $groupms, $lapms, $batteryflag, $corr, $skippedflag);

    $dbsql->commit() if ($TRANSACTIONS);

}   

######################################################################################################################

sub file_io_mode {

    my ($dbsql) = @_;

    #my $rcsv = simple_csv_init('test');
    my $rcsv = SimpleCSV::init('test');

    # iterate across all files specified as arguements
    #
    my $firstflag = 1;
    my $count = 0;
    while (<ARGV>) {

        my $row;

        # initialize prior to each file
        #
        if ($firstflag) {
            $firstflag = 0;
            do_laps_init($dbsql);
            #$row = simple_csv_parse($rcsv, $_, 1);
            $row = SimpleCSV::parse($rcsv, $_, 1);
            next;
        }

        # process current line
        #
        #$row = simple_csv_parse($rcsv, $_, 0);
        $row = SimpleCSV::parse($rcsv, $_, 0);

        #print STDERR Dumper($row);

        unless (defined($row) && $row != 0) {
            #printf STDERR "Empty row skipped\n";
            next;
        }

        do_lap($dbsql, $count++, $row);

        # dump at the end of each file
        #
        if (eof(ARGV)) {
            #printf STDERR "---------\n";
            $firstflag = 1;
            do_laps_finish($dbsql, 0);
        }
    }
    #delete($rcsv);
    #simple_csv_finish($rcscv);

}

######################################################################################################################

my $RestartFlag = 0;
my $FinishedFlag = 0;
my $newfilename = "";
my $dbsql;

sub sighandler {
    my ($sig) = @_;

    my $loginfo = sprintf("lapd: caught signal: %s", $sig);
    syslog('warning', $loginfo);

    printf STDERR "Caught signal: %s\n", $sig;

    if ($sig eq "TERM") {
        $FinishedFlag = 1;
    }
    if ($sig eq "QUIT") {
        $FinishedFlag = 1;
    }
    if ($sig eq "HUP") {
        $FinishedFlag = 1;
    }
    if ($sig eq "INT") {
        $RestartFlag = 1;
    }
}

# newfile
#
# Find the most recently modified file in the current directory.
#
sub newfile {

    if ($FinishedFlag) {

        # check if we are exiting from a SIGHUP
        #
        my $loginfo = sprintf("lapd: terminating", $newfilename);
        syslog('warning', $loginfo);
        printf STDERR "%s\n", $loginfo;
        do_laps_finish($dbsql, 0);
        exit();
    }

    opendir(DIR,'.') || die "Cannot open dot directory\n";
    my @filenames = sort { -M "$a" <=> -M "$b"} readdir(DIR);
    closedir(DIR);

    for (my $i = 0; $i <= $#filenames; $i++) {
        my $filename = $filenames[$i];
        next if ($filename eq '.');
        next if ($filename eq '..');
        next unless ($filename =~ /lapd/);
        printf STDERR "[%2d] %s\n", $i, $filename;
        $newfilename = $filename;
        return $filename;
    }
    printf STDERR "NO FILE\n";
    return "-";
}


######################################################################################################################
# Follow Me Mode.
#
# Find the most recently modified file, tail -c +0 -f the file and process all of data.
#
# If there is no data for 20 seconds check to see if there is a newer file.
#
sub follow_me_mode {

    my ($dbsql) = @_;


    $SIG{ 'TERM' } = 'sighandler';
    $SIG{ 'QUIT' } = 'sighandler';
    $SIG{ 'INT' } = 'sighandler';
    $SIG{ 'HUP' } = 'sighandler';



    # Create a File::Tail object
    #
    my $file = File::Tail->new( 
            name => newfile(), 
            name_changes => \&newfile, 
            maxinterval => 5,               # check once a second
            interval => 1,                  # 
            adjustafter => 5,               # 
            resetafter => 10,               # check for new files every 20 seconds
            tail => -1,                     # return entire file before starting tail mode
            resettail => -1,                # return entire file before starting tail mode
            ignore_nonexistant => 1,        # tolerate missing files       
            debug => 0,
            );


    # wait for input and process
    #
    my $line;
    my $currentfilename = "";

    my $firstflag = 1;

    my $rcsv = SimpleCSV::init('test');

    my $count = 0;
    while (defined($line = $file->read())) {

        printf STDERR "\n\n%s", $line;

        my $row;

        printf STDERR "\n\n%s %s FinishedFlag: %d\n", $currentfilename, $newfilename, $FinishedFlag;


        # log file open/close operations
        #
        if ($currentfilename ne $newfilename) {
            if ($currentfilename) {
                my $loginfo = sprintf("lapd: Closing %sd, Opening File: %s", $currentfilename, $newfilename);
                syslog('warning', $loginfo);
                printf STDERR "%s\n", $loginfo;
                do_laps_finish($dbsql, 0);
            }
            else {
                my $loginfo = sprintf("lapd: Opening File: %s", $newfilename);
                syslog('warning', $loginfo);
                printf STDERR "%s\n", $loginfo;
            }
            $currentfilename = $newfilename;
            do_laps_init($dbsql);
            #$row = simple_csv_parse($rcsv, $line, 1);
            $row = SimpleCSV::parse($rcsv, $line, 1);
            next;
        }


        # check if we need to restart for SIGINT
        #
        if ($RestartFlag) {
            my $loginfo = sprintf("lapd: restarting", $newfilename);
            syslog('warning', $loginfo);
            printf STDERR "%s\n", $loginfo;
            do_laps_finish($dbsql, 0);
            #delete($rcscv);
            #simple_csv_finish($rcscv);
            do_laps_init($dbsql);
            #$row = simple_csv_parse($rcsv, $line, 1);
            $row = SimpleCSV::parse($rcsv, $line, 1);
            next;
        }

        # Parse the input line
        #
        $row = SimpleCSV::parse($rcsv, $line, 0);

        unless (defined($row) && $row != 0) {
            printf STDERR "Empty row skipped\n";
            next;
        }

        unless ($row->{'datestamp'} ne 'datestamp') {
            printf STDERR "Skip header\n";
            next;
        }

        # Process it
        #
        do_lap($dbsql, $count++, $row);
    }
}

######################################################################################################################
######################################################################################################################


$dbsql = DBI->connect("dbi:mysql:$DATABASE", $DBUSER, $DBPASSWORD, { 'PrintError' => 0 }) || die "Cannot connect to mysql\n";

$dbsql->{'AutoCommit'} = 0 if ($TRANSACTIONS);


# File I/O Mode
#
# Process the command arg's as files on STDIN
#
if ($#ARGV >= 0) {

    file_io_mode($dbsql);
    exit();
}

follow_me_mode($dbsql);
#$dbsql->{'AutoCommit'} = 1;

exit();

